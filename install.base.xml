<?xml version="1.0" encoding="UTF-8"?>
<Export generator="Cache" version="25" zv="Cache for UNIX (SUSE Linux Enterprise Server for x86-64) 2015.1 (Build 429U)" ts="2017-02-24 19:10:57">
<Class name="DeclarativeCOS.Binder">
<Description>
Binder collection with function.
Also, class provides implementation of all DeclarativeCOS commands and functions.</Description>
<Super>%RegisteredObject</Super>
<TimeChanged>64333,56078.50453</TimeChanged>
<TimeCreated>64310,74515.461292</TimeCreated>

<Property name="collection">
<Description>
Source collection for processing in DeclarativeCOS commands and functions.</Description>
<Type>%Collection.AbstractList</Type>
<Private>1</Private>
</Property>

<Property name="function">
<Description>
Source function for processing in DeclarativeCOS commands and functions.</Description>
<Type>%String</Type>
<Private>1</Private>
</Property>

<Method name="%OnNew">
<Description>
Overrides "constructor" for the class.</Description>
<FormalSpec>collection:%Collection.AbstractList,function:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
    if ('##class(DeclarativeCOS.Utils).isValidName(function)) {
        set exception = ##class(%Exception.General).%New("Declarative name is invalid", "1",,"Declarative name pattern must be ""namespace:function"".")

        throw exception
    }

    set ..collection = collection

    set ..function = ##class(DeclarativeCOS.Utils).normalizeName(function)

    return $$$OK
]]></Implementation>
</Method>

<Method name="GetCollection">
<Description>
Returns source collection of the binder.</Description>
<Implementation><![CDATA[    return ..collection
]]></Implementation>
</Method>

<Method name="GetFunction">
<Description>
Returns source function of the binder.</Description>
<Implementation><![CDATA[    return ..function
]]></Implementation>
</Method>

<Method name="ForEach">
<Description><![CDATA[

Implementation of "zforeach" command.

Applies the certain function to each element of the collection.

Example:
  NAMESPACE> set collection = ##class(%ListOfDataTypes).%New()
  NAMESPACE> do collection.Insert("Hello ")
  NAMESPACE> do collection.Insert("World!")
  NAMESPACE>
  NAMESPACE> zforeach $zbind(collection, "io:print")

See also:
  DeclarativeCOS.Binder
  DeclarativeCOS.IO#print
]]></Description>
<Implementation><![CDATA[
    quit:..collection=""

    set index = ""

    for {
        set index = ..collection.Next(index)

        quit:index=""

        set item = ..collection.GetAt(index)

        set $lb(className, methodName) = ..loadDeclarative(..function)

        do $classmethod(className, methodName, item)
    }
]]></Implementation>
</Method>

<Method name="Map">
<Description><![CDATA[

Implementation of "$zmap" function.

Returns new collection where each item is result of apply the certain function to source item of the specified collection.

Example:
  NAMESPACE> set numbers = ##class(%ListOfDataTypes).%New()
  NAMESPACE> do numbers.Insert($random(100))
  NAMESPACE> do numbers.Insert($random(100))
  NAMESPACE> do numbers.Insert($random(100))
  NAMESPACE>
  NAMESPACE> write "[" _ $zjoin(numbers, ",") _ "]"
  NAMESPACE> [82,12,27]
  NAMESPACE>
  NAMESPACE> set hexNumbers = $zmap(numbers, "examples:toHex")
  NAMESPACE>
  NAMESPACE> for i=1:1:numbers.Count() { do numbers.SetAt($zhex(numbers.GetAt(i)), i) }
  NAMESPACE>
  NAMESPACE> write "[" _ $zjoin(numbers, ",") _ "]"
  NAMESPACE> [52,C,1B]
  NAMESPACE>
  NAMESPACE> write $zjoin(hexNumbers, ",")
  NAMESPACE> [52,C,1B]

See also:
  DeclarativeCOS.Examples#toHex
  DeclarativeCOS.Joiner#join ($zjoin)
]]></Description>
<Implementation><![CDATA[
    set collection = $classmethod(..collection.%ClassName(), "%New")

    set index = ""

    for {
        set index = ..collection.Next(index)

        quit:index=""

        set item = ..collection.GetAt(index)

        set $lb(className, methodName) = ..loadDeclarative(..function)

        set mappedItem = $classmethod(className, methodName, item)

        do collection.Insert(mappedItem)
    }

    return collection
]]></Implementation>
</Method>

<Method name="Find">
<Description><![CDATA[

Implementation of "$zfind" function.

Returns the first found element from the specified collection by the certain criteria (function).
Otherwise, returns null string.

Example:
  NAMESPACE> set numbers = ##class(%ListOfDataTypes).%New()
  NAMESPACE> do numbers.Insert($random(100))
  NAMESPACE> do numbers.Insert($random(100))
  NAMESPACE> do numbers.Insert($random(100))
  NAMESPACE>
  NAMESPACE> set primeNumber = $zfind(numbers, "examples:isPrime")
  NAMESPACE>
  NAMESPACE> write "[" _ $zjoin(numbers, ",") _ "]"
  NAMESPACE> [69,41,68]
  NAMESPACE>
  NAMESPACE> write "Prime number: " _ $select(primeNumber="":"<not found>", 1:primeNumber)
  NAMESPACE> Prime number: 41

See also:
  DeclarativeCOS.Examples#isPrime
  DeclarativeCOS.Joiner#join ($zjoin)
]]></Description>
<Implementation><![CDATA[
    set index = ""

    for {
        set index = ..collection.Next(index)

        quit:index=""

        set item = ..collection.GetAt(index)

        set $lb(className, methodName) = ..loadDeclarative(..function)

        if ($classmethod(className, methodName, item)) {
            return item
        }
    }

    return ""
]]></Implementation>
</Method>

<Method name="Filter">
<Description><![CDATA[

Implementation of "$zfilter" function.

Returns new collection which contains filtered elements by the certain criteria (function) of the specified collection.

Example:
  NAMESPACE> set numbers = ##class(%ListOfDataTypes).%New()
  NAMESPACE> do numbers.Insert($random(100))
  NAMESPACE> do numbers.Insert($random(100))
  NAMESPACE> do numbers.Insert($random(100))
  NAMESPACE>
  NAMESPACE> set filteredNumbers = $zfilter(numbers, "examples:isOdd")
  NAMESPACE>
  NAMESPACE> write "[" _ $zjoin(numbers, ",") _ "]"
  NAMESPACE> [22,71,31]
  NAMESPACE>
  NAMESPACE> write "[" _ $zjoin(filteredNumbers, ",") _ "]"
  NAMESPACE> [71,31]

See also:
  DeclarativeCOS.Examples#isOdd
  DeclarativeCOS.Joiner#join ($zjoin)
]]></Description>
<Implementation><![CDATA[
    set collection = $classmethod(..collection.%ClassName(), "%New")

    set index = ""

    for {
        set index = ..collection.Next(index)

        quit:index=""

        set item = ..collection.GetAt(index)

        set $lb(className, methodName) = ..loadDeclarative(..function)

        if ($classmethod(className, methodName, item)) {
            do collection.Insert(item)
        }
    }

    return collection
]]></Implementation>
</Method>

<Method name="Exists">
<Description><![CDATA[

Implementation of "$zexists" function.

Returns $$$YES if collection contains element which is satisfied by by the certain criteria (function).
Otherwise, returns $$$NO.

Example:
  NAMESPACE> set numbers = ##class(%ListOfDataTypes).%New()
  NAMESPACE> do numbers.Insert($random(100))
  NAMESPACE> do numbers.Insert($random(100))
  NAMESPACE> do numbers.Insert($random(100))
  NAMESPACE>
  NAMESPACE> set hasEvenNumbers = $zexists(numbers, "examples:isEven")
  NAMESPACE>
  NAMESPACE> write "[" _ $zjoin(numbers, ",") _ "]"
  NAMESPACE> [51,56,53]
  NAMESPACE>
  NAMESPACE> write "Collection has" _ $case(hasEvenNumbers, 1:" ", 0:" no ") _ "even numbers"
  NAMESPACE> Collection has even numbers

See also:
  DeclarativeCOS.Examples#isEven
  DeclarativeCOS.Joiner#join ($zjoin)
]]></Description>
<Implementation><![CDATA[    return ..Find() '= ""
]]></Implementation>
</Method>

<Method name="Count">
<Description><![CDATA[

Implementation of "$zcount" function.

Returns $$$YES if collection contains element which is satisfied by the certain criteria (function).
Otherwise, returns $$$NO.

Example:
  NAMESPACE> set numbers = ##class(%ListOfDataTypes).%New()
  NAMESPACE> do numbers.Insert($random(1000))
  NAMESPACE> do numbers.Insert($random(1000))
  NAMESPACE> do numbers.Insert($random(1000))
  NAMESPACE>
  NAMESPACE> set palindromicNumbersCount = $zcount(numbers, "examples:isPalindromic")
  NAMESPACE>
  NAMESPACE> write "[" _ $zjoin(numbers, ",") _ "]"
  NAMESPACE> [715,202,898]
  NAMESPACE>
  NAMESPACE> write "Count of palindromic numbers: " _ palindromicNumbersCount
  NAMESPACE> Count of palindromic numbers: 2

See also:
  DeclarativeCOS.Examples#isPalindromic
  DeclarativeCOS.Joiner#join ($zjoin)
]]></Description>
<Implementation><![CDATA[
    set count = 0

    set index = ""

    for {
        set index = ..collection.Next(index)

        quit:index=""

        set item = ..collection.GetAt(index)

        set $lb(className, methodName) = ..loadDeclarative(..function)

        if ($classmethod(className, methodName, item)) {
            set count = count + 1
        }
    }

    return count
]]></Implementation>
</Method>

<Method name="loadDeclarative">
<Description>
Delegates call to DeclarativesManager#loadDeclarative

See also:
  DeclarativeCOS.DeclarativesManager#loadDeclarative
</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>function:%String</FormalSpec>
<Private>1</Private>
<Implementation><![CDATA[    return ##class(DeclarativeCOS.DeclarativesManager).loadDeclarative(function)
]]></Implementation>
</Method>
</Class>


<Class name="DeclarativeCOS.BinderTests">
<Super>%UnitTest.TestCase,DeclarativeCOS.DeclarativeProvider</Super>
<TimeChanged>64333,59541.9367</TimeChanged>
<TimeCreated>64331,41518.508777</TimeCreated>

<Parameter name="TESTGLOBALNAME">
<Type>%String</Type>
<Default>^DeclarativeCOSTests</Default>
</Parameter>

<Method name="toGlobal">
<Description>
@Declarative("test.forEach:toGlobal")</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>word:%String</FormalSpec>
<Implementation><![CDATA[
    set global = $name(@..#TESTGLOBALNAME@("forEach"))

    if ('$data(@global@("word1"))) { set @global@("word1") = word }

    elseif ('$data(@global@("word2"))) { set @global@("word2") = word }

    elseif ('$data(@global@("word3"))) { set @global@("word3") = word }
]]></Implementation>
</Method>

<Method name="TestForEach">
<Implementation><![CDATA[
    set global = $name(@..#TESTGLOBALNAME@("forEach"))

    kill @global

    set $lb(word1, word2, word3) = $lb("ForEach", "is", "available")

    set words = ##class(%ListOfDataTypes).%New()
    do words.Insert(word1)
    do words.Insert(word2)
    do words.Insert(word3)

    zforeach $zbind(words, "test.forEach:toGlobal")

    do $$$AssertEquals(word1, $get(@global@("word1")), "Word #1 is equal")
    do $$$AssertEquals(word2, $get(@global@("word2")), "Word #2 is equal")
    do $$$AssertEquals(word3, $get(@global@("word3")), "Word #3 is equal")

    kill @global
]]></Implementation>
</Method>

<Method name="TestMap">
<Implementation><![CDATA[
    set numbers = ##class(%ListOfDataTypes).%New()

    for i=1:1:10 { do numbers.Insert($random(1000)) }

    set hexNumbers = $zmap(numbers, "examples:toHex")

    for i=1:1:numbers.Count() { do numbers.SetAt($zhex(numbers.GetAt(i)), i) }

    do $$$AssertEquals($zjoin(numbers, ","), $zjoin(hexNumbers, ","), "$zmap works!")
]]></Implementation>
</Method>

<Method name="TestFind">
<Implementation><![CDATA[
    set numbers = ##class(%ListOfDataTypes).%New()

    for i=1:1:10 { do numbers.Insert($random(1000)) }

    set expectedPrimeNumber = ""

    for i=1:1:numbers.Count() {
        set number = numbers.GetAt(i)

        if (##class(DeclarativeCOS.Examples).isPrime(number)) {
            set expectedPrimeNumber = number
        }

        quit:expectedPrimeNumber'=""
    }

    set actualPrimeNumber = $zfind(numbers, "examples:isPrime")

    do $$$AssertEquals(expectedPrimeNumber, actualPrimeNumber, "$zfind works!")
]]></Implementation>
</Method>

<Method name="TestFilter">
<Implementation><![CDATA[
    set numbers = ##class(%ListOfDataTypes).%New()

    for i=1:1:10 { do numbers.Insert($random(1000)) }

    set expectedFilteredNumbers = ##class(%ListOfDataTypes).%New()

    for i=1:1:numbers.Count() {
        set number = numbers.GetAt(i)

        if (##class(DeclarativeCOS.Examples).isOdd(number)) {
            do expectedFilteredNumbers.Insert(number)
        }
    }

    set actualFilteredNumbers = $zfilter(numbers, "examples:isOdd")

    do $$$AssertEquals($zjoin(expectedFilteredNumbers, ","), $zjoin(actualFilteredNumbers, ","), "$zfilter works!")
]]></Implementation>
</Method>

<Method name="TestExists">
<Implementation><![CDATA[
    set numbers = ##class(%ListOfDataTypes).%New()

    for i=1:1:10 { do numbers.Insert($random(1000)) }

    set expectedHasEvenNumber = $$$NO

    for i=1:1:numbers.Count() {
        set number = numbers.GetAt(i)

        if (##class(DeclarativeCOS.Examples).isEven(number)) {
            set expectedHasEvenNumber = $$$YES
        }

        quit:expectedHasEvenNumber'=""
    }

    set actualHasEvenNumber = $zexists(numbers, "examples:isEven")

    do $$$AssertEquals(expectedHasEvenNumber, actualHasEvenNumber, "$zexists works!")
]]></Implementation>
</Method>

<Method name="TestCount">
<Implementation><![CDATA[
    set numbers = ##class(%ListOfDataTypes).%New()

    for i=1:1:10 { do numbers.Insert($random(1000)) }

    set expectedPalindromicNumbersCount = 0

    for i=1:1:numbers.Count() {
        set number = numbers.GetAt(i)

        if (##class(DeclarativeCOS.Examples).isPalindromic(number)) {
            set expectedPalindromicNumbersCount = $increment(expectedPalindromicNumbersCount)
        }
    }

    set actualPalindromicNumbersCount = $zcount(numbers, "examples:isPalindromic")

    do $$$AssertEquals(expectedPalindromicNumbersCount, actualPalindromicNumbersCount, "$zcount works!")
]]></Implementation>
</Method>
</Class>


<Class name="DeclarativeCOS.DeclarativeProvider">
<Description>
The heart of DeclarativeCOS!
All declarative providers must extend the class.</Description>
<TimeChanged>64333,54884.131132</TimeChanged>
<TimeCreated>64310,74515.415686</TimeCreated>

<Method name="register">
<Description>
The DeclarativeCOS magic.
Code generator for registration declaratives in
special global: ^DeclarativeCOS</Description>
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<Implementation><![CDATA[
    if (%compiledclass.Name = "DeclarativeCOS.DeclarativeProvider") {
        kill ^DeclarativeCOS
    }

    set methods = %compiledclass.Methods

    set i = ""

    for {
        set i = methods.Next(i)

        quit:i=""

        set method = methods.GetAt(i)

        set methodName = method.Name

        set methodDescription = method.Description

        continue:methodName="register"

        continue:$extract(methodName)="%"

        set declarativeNameRegex = ##class(DeclarativeCOS.Utils).#DECLARATIVENAMEREGEX

        set annotationRegexp = "@Declarative\(""(" _ declarativeNameRegex _ ")""\)"

        set annotationMatcher = ##class(%Regex.Matcher).%New(annotationRegexp, methodDescription)

        if (annotationMatcher.Locate()) {
            set annotationValue = $replace(annotationMatcher.Group(1), " ", "")

            do ##class(DeclarativeCOS.DeclarativesManager).saveDeclarative(annotationValue, %compiledclass.Name, methodName)
        }
    }

    d %code.WriteLine("    q")

    q $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="DeclarativeCOS.DeclarativesManager">
<Description>
Manager for declaratives.
The class contains methods for saving and retrieving declaratives from ^DeclarativeCOS global.</Description>
<TimeChanged>64333,54884.241798</TimeChanged>
<TimeCreated>64310,74515.494542</TimeCreated>

<Method name="saveDeclarative">
<Description>
Stores declarative to the ^DeclarativeCOS global.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>declarativeName:%String,className:%String,functionName:%String</FormalSpec>
<Implementation><![CDATA[    set ^DeclarativeCOS("functions", declarativeName) = $lb(className, functionName)
]]></Implementation>
</Method>

<Method name="loadDeclarative">
<Description>
Loads declarative from the ^DeclarativeCOS global.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>declarativeName:%String</FormalSpec>
<Implementation><![CDATA[    return $get(^DeclarativeCOS("functions", declarativeName))
]]></Implementation>
</Method>
</Class>


<Class name="DeclarativeCOS.Examples">
<Description>
Set of DeclarativeCOS examples.</Description>
<Super>DeclarativeCOS.DeclarativeProvider</Super>
<TimeChanged>64333,54883.985706</TimeChanged>
<TimeCreated>64333,42037.525974</TimeCreated>

<Method name="toHex">
<Description>
Returns hex value of the passed value.

@Declarative("examples:toHex")</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>value:%Numeric</FormalSpec>
<Implementation><![CDATA[    return $zhex(value)
]]></Implementation>
</Method>

<Method name="isPrime">
<Description>
Returns $$$YES if passed value is prime number.
Otherwise, returns $$$NO.

@Declarative("examples:isPrime")</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>value:%Numeric</FormalSpec>
<Implementation><![CDATA[
    for i=2:1:$zsqr(value) {
        if (value # i = 0) {
            return $$$NO
        }
    }

    return $$$YES
]]></Implementation>
</Method>

<Method name="isOdd">
<Description>
Returns $$$YES if passed value is odd number.
Otherwise, returns $$$NO.

@Declarative("examples:isOdd")</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>value:%Numeric</FormalSpec>
<Implementation><![CDATA[    return value # 2 '= 0
]]></Implementation>
</Method>

<Method name="isEven">
<Description>
Returns $$$YES if passed value is even number.
Otherwise, returns $$$NO.

@Declarative("examples:isEven")</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>value:%Numeric</FormalSpec>
<Implementation><![CDATA[    return value # 2 = 0
]]></Implementation>
</Method>

<Method name="isPalindromic">
<Description>
Returns $$$YES if passed value is palindromic number.
Otherwise, returns $$$NO.

@Declarative("examples:isPalindromic")</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>value:%Numeric</FormalSpec>
<Implementation><![CDATA[    return $reverse(value) = value
]]></Implementation>
</Method>
</Class>


<Class name="DeclarativeCOS.IO">
<Description><![CDATA[
The class provides IO declaratives.
io:print <-> w value
io:println <-> w value, !]]></Description>
<Super>DeclarativeCOS.DeclarativeProvider</Super>
<TimeChanged>64333,54883.949985</TimeChanged>
<TimeCreated>64310,74515.269825</TimeCreated>

<Method name="print">
<Description>
Output passed value.

@Declarative("io:print")</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>value:%Library.DataType</FormalSpec>
<Implementation><![CDATA[    w value
]]></Implementation>
</Method>

<Method name="println">
<Description>
Output passed value. Add newline symbol.

@Declarative("io:println")</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>value:%Library.DataType</FormalSpec>
<Implementation><![CDATA[    w value, !
]]></Implementation>
</Method>
</Class>


<Class name="DeclarativeCOS.Joiner">
<Description>
Joiner is a kind of text utils class.
The main point of the class is join elemenet of collection using separator.</Description>
<TimeChanged>64333,54884.208873</TimeChanged>
<TimeCreated>64331,32416.504776</TimeCreated>

<Method name="join">
<Description><![CDATA[
Returns string from elements of the specified collection usin the certain separator.
Example:
  NAMESPACE> set words = ##class(%ListOfDataTypes).%New()
  NAMESPACE> do words.Insert("DeclarativeCOS")
  NAMESPACE> do words.Insert("is")
  NAMESPACE> do words.Insert("awesome!")
  NAMESPACE>
  NAMESPACE> write $jzoin(words, " ")
  NAMESPACE> DeclarativeCOS is awesome!]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>collection:%Collection.AbstractList,separator:%String=""</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
    if (collection = "") {
      return ""
    }

    set string = ""

    set index = ""

    for {
        set index = collection.Next(index)

        quit:index=""

        set item = collection.GetAt(index)

        if (string = "") {
            set string = "" _ item
        }
        else {
            set string = string _ separator _ item
        }
    }

    return string
]]></Implementation>
</Method>
</Class>


<Class name="DeclarativeCOS.JoinerTests">
<Super>%UnitTest.TestCase</Super>
<TimeChanged>64333,59580.764643</TimeChanged>
<TimeCreated>64331,41554.388774</TimeCreated>

<Method name="TestJoin">
<Implementation><![CDATA[
    set words = ##class(%ListOfDataTypes).%New()
    do words.Insert("DeclarativeCOS")
    do words.Insert("is")
    do words.Insert("awesome!")

    do $$$AssertEquals("DeclarativeCOS is awesome!", $zjoin(words, " "), "$zjoin works!")
]]></Implementation>
</Method>
</Class>


<Class name="DeclarativeCOS.Utils">
<Description>
Some utils for DeclarativeCOS implementation.</Description>
<TimeChanged>64333,54884.047405</TimeChanged>
<TimeCreated>64325,61273.204204</TimeCreated>

<Parameter name="DECLARATIVENAMEREGEX">
<Description>
Declarative name regular expression.
The pattern is "namespace:function"</Description>
<Internal>1</Internal>
<Default>[a-zA-Z0-9]+(.[a-zA-Z0-9]+)*\s*:\s*[a-zA-Z0-9]+([a-zA-Z0-9_]+)*</Default>
</Parameter>

<Method name="isValidName">
<Description>
Returns $$$YES if specified name is satisfied by the DECLARATIVENAMEREGEX regex.
Otherwise, returns $$$NO.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[    return ##class(%Regex.Matcher).%New("^" _ ..#DECLARATIVENAMEREGEX _ "$", name).Locate()
]]></Implementation>
</Method>

<Method name="normalizeName">
<Description>
Returns declarative name without any space characters.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
    if (..isValidName(name)) {
        return $replace(name, " ", "")
    }

    return name
]]></Implementation>
</Method>
</Class>


<Class name="External.Manager.DeclarativeCOS">
<TimeChanged>64333,42004.82458</TimeChanged>
<TimeCreated>64307,54762.708232</TimeCreated>

<Method name="getWorkspacePath">
<ClassMethod>1</ClassMethod>
<Private>1</Private>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[    return "/opt/dcos/dcos-cls/"
]]></Implementation>
</Method>

<Method name="getWorkspaceSourcesPath">
<ClassMethod>1</ClassMethod>
<Private>1</Private>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[    return (..getWorkspacePath())_"src/"
]]></Implementation>
</Method>

<Method name="getWorkspaceTestsPath">
<ClassMethod>1</ClassMethod>
<Private>1</Private>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[    return (..getWorkspacePath())_"test/"
]]></Implementation>
</Method>

<Method name="getSources">
<ClassMethod>1</ClassMethod>
<Private>1</Private>
<ReturnType>%Library.ListOfDataTypes</ReturnType>
<Implementation><![CDATA[
    s sources = ##class(%Library.ListOfDataTypes).%New()
    d sources.Insert("DeclarativeCOS.IO")
    d sources.Insert("DeclarativeCOS.Examples")
    d sources.Insert("DeclarativeCOS.Utils")
    d sources.Insert("DeclarativeCOS.DeclarativeProvider")
    d sources.Insert("DeclarativeCOS.Binder")
    d sources.Insert("DeclarativeCOS.Joiner")
    d sources.Insert("DeclarativeCOS.DeclarativesManager")

    return sources
]]></Implementation>
</Method>

<Method name="getTests">
<ClassMethod>1</ClassMethod>
<Private>1</Private>
<ReturnType>%Library.ListOfDataTypes</ReturnType>
<Implementation><![CDATA[
    s tests = ##class(%Library.ListOfDataTypes).%New()
    d tests.Insert("DeclarativeCOS.BinderTests")
    d tests.Insert("DeclarativeCOS.JoinerTests")

    return tests
]]></Implementation>
</Method>

<Method name="compile">
<ClassMethod>1</ClassMethod>
<Private>1</Private>
<Implementation><![CDATA[    do ##class(%SYSTEM.OBJ).CompilePackage("DeclarativeCOS")
]]></Implementation>
</Method>

<Method name="importCLS">
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String,path:%String</FormalSpec>
<Private>1</Private>
<Implementation><![CDATA[
    set status = ##class(%Compiler.UDL.TextServices).SetTextFromFile("USER", className, path_className_".cls")

    w !,"[",$case(status, 1:"OK",:"FAILED"),"] ",className
]]></Implementation>
</Method>

<Method name="importSourcesCLS">
<ClassMethod>1</ClassMethod>
<FormalSpec>path:%String</FormalSpec>
<Private>1</Private>
<Implementation><![CDATA[
    set sources = ..getSources()

    set index = sources.Next("")

    while (index '= "") {
      set source = sources.GetAt(index)

      do ..importCLS(source, path)

      set index = sources.Next(index)
    }
]]></Implementation>
</Method>

<Method name="importTestsCLS">
<ClassMethod>1</ClassMethod>
<FormalSpec>path:%String</FormalSpec>
<Private>1</Private>
<Implementation><![CDATA[
    set tests = ..getTests()

    set index = tests.Next("")

    while (index '= "") {
      set test = tests.GetAt(index)

      do ..importCLS(test, path)

      set index = tests.Next(index)
    }
]]></Implementation>
</Method>

<Method name="exportCLS">
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String,path:%String</FormalSpec>
<Private>1</Private>
<Implementation><![CDATA[
    set status = ##class(%Compiler.UDL.TextServices).GetTextAsFile("USER", className, path_className_".cls")

    w !,"[",$case(status, 1:"OK", :"FAILDER"),"] ", className
]]></Implementation>
</Method>

<Method name="exportSourcesCLS">
<ClassMethod>1</ClassMethod>
<FormalSpec>path:%String</FormalSpec>
<Private>1</Private>
<Implementation><![CDATA[
    set sources = ..getSources()

    set index = sources.Next("")

    while (index '= "") {
      set source = sources.GetAt(index)

      do ..exportCLS(source, path)

      set index = sources.Next(index)
    }
]]></Implementation>
</Method>

<Method name="exportTestsCLS">
<ClassMethod>1</ClassMethod>
<FormalSpec>path:%String</FormalSpec>
<Private>1</Private>
<Implementation><![CDATA[
    set tests = ..getTests()

    set index = tests.Next("")

    while (index '= "") {
      set test = tests.GetAt(index)

      do ..exportCLS(test, path)

      set index = tests.Next(index)
    }
]]></Implementation>
</Method>

<Method name="exportXML">
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String,path:%String</FormalSpec>
<Implementation><![CDATA[    w !,$system.OBJ.Export(className_".cls", path_$translate(className, ".", "/")_".cls.xml", "/diffexport")
]]></Implementation>
</Method>

<Method name="exportTestsXML">
<ClassMethod>1</ClassMethod>
<FormalSpec>path:%String</FormalSpec>
<Implementation><![CDATA[
    set tests = ..getTests()
 
    set index = tests.Next("")
 
    while (index '= "") {
      set test = tests.GetAt(index)
 
      do ..exportXML(test, path)
 
      set index = tests.Next(index)
    }
]]></Implementation>
</Method>

<Method name="importWorkspace">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
    do ..importSourcesCLS(..getWorkspaceSourcesPath())

    do ..importTestsCLS(..getWorkspaceTestsPath())
]]></Implementation>
</Method>

<Method name="exportWorkspace">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
    do ..exportSourcesCLS(..getWorkspaceSourcesPath())

    do ..exportTestsCLS(..getWorkspaceTestsPath())

    do ..exportTestsXML(..getWorkspaceTestsPath())
]]></Implementation>
</Method>

<Method name="buildWorkspace">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
    do ..importWorkspace()

    do ..compile()

    do ..exportWorkspace()
]]></Implementation>
</Method>
</Class>
</Export>
